\documentclass[a4paper]{article}
\usepackage{lipsum}

% PACKAGES FOR REFERENCES & BIBLIOGRAPHY
\usepackage[colorlinks=true,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=black,menucolor=black,runcolor=black,urlcolor=black]{hyperref} % Adds clickable links at references
\usepackage[acronym]{glossaries}
\usepackage[backend=biber, style=numeric, giveninits=true, maxcitenames=2]{biblatex} % Square brackets, citing references with numbers, citations sorted by appearance in the text and compressed
\addbibresource{biblio.bib}
\usepackage{cleveref}
\usepackage{todonotes}
\usepackage{amsfonts}

\author{Michele De Pascalis}
\title{Midterm Report}

\newacronym{itt}{ITT}{Intensional Type Theory}
\newacronym{mltt}{MLTT}{Martin-LÃ¶f Type Theory}
\newacronym{lccc}{LCCC}{Locally Cartesian Closed Category}

\makeglossaries

\DeclareMathOperator{\map}{map}
\newcommand{\catname}[1]{{\normalfont\textbf{#1}}}
\newcommand{\Set}{\catname{Set}}

\begin{document}
\maketitle

\section{Preliminaries}

\section{DELETE ME}

\begin{enumerate}

	\item Tentative title: Inductive principles in Intensional Type Theory
	\item Constructive constructions (haha) of W-types
	\item Polynomials are justified to try to model HITs algebraically rather than homotopically.
\end{enumerate}

\subsection{Type Theory}

Type theory is a formal discipline that appeared in the 20th century in the mathematical niche that has today developed into computer science. In its current incarnations, a type theory is composed of some equational theory (most popularly some flavour of Church's \(\lambda\)-calculus), enriched with a deductive system with the aim of assigning \textit{types} to the terms.

Type theory has proved to be of great use for the study of mathematics and computer science alike. Type theoretical analysis enables formal reasoning about properties of programs; The types assigned to parts of a program, themselves, witness properties of the program. If the procedure of verifying that a term can be given a certain type (called \textit{type-checking}) can be automatized, this workflow can be employed by software developers to state and ensure properties of the produced software. Not surprisingly, a lot of legacy and modern computer programming languages feature type systems inspired by some type theory.

On the other hand, the tradition that birthed type theory is rooted in the disciplinary scope of logic and foundation of mathematics. Many type theories are concretely logical deductive system, and as such they are studied by modern logic. In the seventies, \textcite{MartinLoef1998} developed \gls{itt}, the first of a family of type theories that is now referred to as \gls{mltt}. Type theories in the \gls{mltt} family feature \textit{dependent types}, i.e. the possibility for types to depend on terms in their contexts, and so-called \textit{identity types}, i.e. types encoding the equality of two terms. These features allow \gls{mltt} to be used as a deductive system for constructive predicate logic.

The possibility of using some flavor of \gls{mltt} as a foundation for constructive mathematics is appealing not only for logicians and computer scientists, but also for mathematicians who seek a tool to formally validate their mathematical production. In the logical interpretation of \gls{mltt}, propositions (and therefore theorems) are interpreted as types, and proofs of a proposition correspond to terms that inhabit the corresponding type. When type-checking is decidable for a variant of \gls{mltt} (for instance, it is for \gls{itt}\todo{cite}), then a computer can be used to check that a proof for a theorem is valid, by encoding both into type theory, and then asking the type-checker. A notable example of such an automated system for formalizing mathematics is the proof assistant Agda\todo{cite}.

\subsection{Category Theory}

Category theory (see \cite{Riehl2017} for a reference) is a branch of mathematics studying compositional structures called \textit{categories}. Briefly put, a category is composed of the following data:

\begin{enumerate}
	\item A collection of objects \(A, B, C, ...\);
	\item For any two objects \(A, B\), a collection of arrows \(\hom(A, B)\);
	\item For any object \(A\), a special arrow \(id_A : \hom(A, A)\), called the \textit{identity} on \(A\);
	\item For any three objects \(A, B, C\) and two arrows \(f : \hom(A, B), g : \hom(B, C)\), an arrow \(f ; g : \hom(A, C)\), called the \textit{composite} of \(f\) and \(g\).
\end{enumerate}

These components have to satisfy the following additional requirements:

\begin{enumerate}
	\item Associativity: for any three arrows \(A \xrightarrow{f} B \xrightarrow{g} C \xrightarrow{h} D\), \(f ; (g ; h) = (f ; g) ; h\);
	\item Unitality: for any arrow \(A \xrightarrow{f} B\), \(id_A ; f = f = f ; id_B\).
\end{enumerate}

Categories are ubiquitous in mathematics and computer science (cf. \cite{Walters1992}). Sets with functions form a category (notated as \Set{}), as do most flavors of algebraic structures with homomorphisms, and topological spaces with transformation of the corresponding kind. In computer programming, processes with input type \(A\) and output type \(B\) can be seen as arrows from \(A\) to \(B\), and as such they form a category.

\subsection{Polynomial Functors and Containers}

In category theory, a \textit{functor} \(F : \mathcal C \to \mathcal D\) is a mapping between categories \(\mathcal C\) and \(\mathcal D\) that is compatible with the category structures, in the sense that objects are mapped to objects, and arrows \(A \xrightarrow{f} B\) in \(\mathcal C\) are mapped to arrows \(\map_F f : F A \to F B\) between the mapped endpoints in \(\mathcal D\), preserving identity and composition.

In programming languages, mapping between types more often then not come with an implicit functorial structure. This is acknowledged by instances of the \texttt{Functor} typeclass in the Haskell standard library.

In particular, user-defined composite non-recursive type declarations usually fit in a class of functors referred to as \textit{polynomial functors}. There are several overlapping formal definitions of polynomial functors\footnote{In \cite{Goldblatt2001} they appear defined as \Set{}-endofunctors ``constructed from constant functors and [the identity functor] by finitely many applications of products, coproducts and powers''. \textcite{Moerdijk2000} give a definition in any pretopos; \textcite{Gambino2004} give a definition in any \gls{lccc}; \textcite{Gambino2009} give a definition for indexed polynomial functors also in a \gls{lccc}.}, but they all stem from considering functors whose object mapping resembles a polynomial in its argument, e.g.

\begin{equation}
	\label{eqn:list-functor}
	F X := 1 + A \times X
\end{equation}

Where operators \(+\) and \(\times\) stand for coproducts and products in the relevant category. In the category of sets, these are respectively the disjoint union and the cartesian product. In programming languages, they are respectively tagged enums (or sum types) and pairs (or product types). In Haskell parlance, the functor in def. \ref{eqn:list-functor} can be defined by:

\begin{verbatim}
  data F x = Left | Right A x 
\end{verbatim}

The apparent syntactic structure of polynomial functors motivates the search for a more synthetic definition that fully and faithfully captures them. One approach to this is the study of \textit{containers} \cite{Abbott2003}\cite{Abbott2005}\cite{Altenkirch2015}(indexed version), which are then associated to endofunctors on \Set{} or \Set{}-slices. Note that these definitions are not \textit{per se} limited to \Set{}, since they are given and validated in a \gls{mltt}; however, due to the difficulty of precisely identifying the class of structures that \gls{mltt} describes\footnote{For an informal discussion, see \cite{Voevodsky2015}.}, it is not immediate to understand how general they are. Analogous issues arise in trying to understand to what flavors of polynomial functors containers correspond.

To further complicate the picture, \textcite{Gambino2009} took a step further and generalised this syntactic approach to syntaxes defined in a general \gls{lccc}, yielding a theory covering indexed polynomial functors in \gls{lccc} slices similarly to how \cite{Altenkirch2015} cover indexed polynomial functors in \Set{}-slices. Again, it is not clear to what extent these theories overlap.

\subsection{Inductive Principles as Initial Algebras}

In both logic and computer science, it is common to encounter definitions given by recursion, as well as proofs given by induction. An example of a recursive definition is the following definition of a function giving the parity of a natural number:

\begin{verbatim}
isEven : Nat -> Bool
isEven zero = true
isEven (succ n) = not (isEven n)
\end{verbatim}

A recursion principle for the type \(\mathbb N\) of natural numbers can be stated as follows: ``Given any type \(A\), giving a function \(f : \mathbb N \to A\) amounts precisely to giving \(z : A\) and \(s : A \to A\), such that \(z = f(0)\) and \(\forall n : \mathbb N . s(f(n)) = f (n + 1)\)''.

\section{Project Description}

\subsection{Overview of known results}

\subsection{Goals}

\section{Current Work}

\section{Future Work}



\printacronyms
\printbibliography

\end{document}
