\documentclass[a4paper]{article}
\usepackage{lipsum}

% PACKAGES FOR REFERENCES & BIBLIOGRAPHY
\PassOptionsToPackage{hyphens}{url}\usepackage[colorlinks=true,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=black,menucolor=black,runcolor=black,urlcolor=blue]{hyperref} % Adds clickable links at references
\usepackage[acronym]{glossaries}
\usepackage[backend=biber, style=numeric, giveninits=true, maxcitenames=2]{biblatex} % Square brackets, citing references with numbers, citations sorted by appearance in the text and compressed
\addbibresource{biblio.bib}
\usepackage{cleveref}
\usepackage{todonotes}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{subfig}
\author{Michele De Pascalis}
\title{Midterm Report}

\newacronym{itt}{ITT}{Intensional Type Theory}
\newacronym{mltt}{MLTT}{Martin-Löf Type Theory}
\newacronym{lccc}{LCCC}{Locally Cartesian Closed Category}
\newacronym{uip}{UIP}{Uniqueness of Identity Proofs}
\newacronym{hit}{HIT}{Higher Inductive Type}
\newacronym{hott}{HoTT}{Homotopy Type Theory}

\makeglossaries

\DeclareMathOperator{\map}{map}
\newcommand{\catname}[1]{{\normalfont\textbf{#1}}}
\newcommand{\Set}{\catname{Set}}

\lstset{basicstyle=\ttfamily\small}

\begin{document}
\maketitle

\section{Preliminaries}

\subsection{Type Theory}

Type theory is a formal discipline that appeared in the 20th century in the mathematical niche that has today developed into computer science. In its current incarnations, a type theory is composed of some equational theory (most popularly some flavour of Church's \(\lambda\)-calculus), enriched with a deductive system with the aim of assigning \textit{types} to the terms.

Type theory has proved to be of great use for the study of mathematics and computer science alike. Type theoretical analysis enables formal reasoning about properties of programs; The types assigned to parts of a program, themselves, witness properties of the program. If the procedure of verifying that a term can be given a certain type (called \textit{type-checking}) can be automatized, this workflow can be employed by software developers to state and ensure properties of the produced software. Not surprisingly, a lot of legacy and modern computer programming languages feature type systems inspired by some type theory.

On the other hand, the tradition that birthed type theory is rooted in the disciplinary scope of logic and foundation of mathematics. Many type theories are concretely logical deductive system, and as such they are studied by modern logic. In the seventies, \textcite{MartinLoef1998} developed \gls{itt}, the first of a family of type theories that is now referred to as \gls{mltt}. Type theories in the \gls{mltt} family feature \textit{dependent types}, i.e. the possibility for types to depend on terms in their contexts, and so-called \textit{identity types}, i.e. types encoding the equality of two terms. These features allow \gls{mltt} to be used as a deductive system for constructive predicate logic.

The possibility of using some flavor of \gls{mltt} as a foundation for constructive mathematics is appealing not only for logicians and computer scientists, but also for mathematicians who seek a tool to formally validate their mathematical production. In the logical interpretation of \gls{mltt}, propositions (and therefore theorems) are interpreted as types, and proofs of a proposition correspond to terms that inhabit the corresponding type. When type-checking is decidable for a variant of \gls{mltt} (for instance, it is for \gls{itt}\todo{cite}), then a computer can be used to check that a proof for a theorem is valid, by encoding both into type theory, and then asking the type-checker. A notable example of such an automated system for formalizing mathematics is the proof assistant Agda \cite{Norell2009}.

\subsection{Category Theory}

Category theory (see \cite{Riehl2017} for a reference) is a branch of mathematics studying compositional structures called \textit{categories}. Briefly put, a category is composed of the following data:

\begin{enumerate}
	\item A collection of objects \(A, B, C, ...\);
	\item For any two objects \(A, B\), a collection of arrows \(\hom(A, B)\);
	\item For any object \(A\), a special arrow \(id_A : \hom(A, A)\), called the \textit{identity} on \(A\);
	\item For any three objects \(A, B, C\) and two arrows \(f : \hom(A, B), g : \hom(B, C)\), an arrow \(f ; g : \hom(A, C)\), called the \textit{composite} of \(f\) and \(g\).
\end{enumerate}

These components have to satisfy the following additional requirements:

\begin{enumerate}
	\item Associativity: for any three arrows \(A \xrightarrow{f} B \xrightarrow{g} C \xrightarrow{h} D\), \(f ; (g ; h) = (f ; g) ; h\);
	\item Unitality: for any arrow \(A \xrightarrow{f} B\), \(id_A ; f = f = f ; id_B\).
\end{enumerate}

Categories are ubiquitous in mathematics and computer science (cf. \cite{Walters1992}). Sets with functions form a category (notated as \Set{}), as do most flavors of algebraic structures with homomorphisms, and topological spaces with transformation of the corresponding kind. In computer programming, processes with input type \(A\) and output type \(B\) can be seen as arrows from \(A\) to \(B\), and as such they form a category.

\subsection{Polynomial Functors and Containers}

In category theory, a \textit{functor} \(F : \mathcal C \to \mathcal D\) is a mapping between categories \(\mathcal C\) and \(\mathcal D\) that is compatible with the category structures, in the sense that objects are mapped to objects, and arrows \(A \xrightarrow{f} B\) in \(\mathcal C\) are mapped to arrows \(\map_F f : F A \to F B\) between the mapped endpoints in \(\mathcal D\), preserving identity and composition.

In programming languages, mapping between types more often then not come with an implicit functorial structure. This is acknowledged by instances of the \texttt{Functor} typeclass in the Haskell standard library.

In particular, user-defined composite non-recursive type declarations usually fit in a class of functors referred to as \textit{polynomial functors}. There are several overlapping formal definitions of polynomial functors\footnote{In \textcite{Goldblatt2001} they appear defined as \Set{}-endofunctors ``constructed from constant functors and [the identity functor] by finitely many applications of products, coproducts and powers''. \textcite{Moerdijk2000} give a definition in any pretopos; \textcite{Gambino2004} give a definition in any \gls{lccc}; \textcite{Gambino2009} give a definition for indexed polynomial functors also in a \gls{lccc}.}, but they all stem from considering functors whose object mapping resembles a polynomial in its argument, e.g.

\begin{equation}
	\label{eqn:list-functor}
	F X := 1 + A \times X
\end{equation}

Where operators \(+\) and \(\times\) stand for coproducts and products in the relevant category. In the category of sets, these are respectively the disjoint union and the cartesian product. In programming languages, they are respectively tagged enums (or sum types) and pairs (or product types). In Haskell parlance, the functor in def. \ref{eqn:list-functor} can be defined by:

\begin{lstlisting}
  data F x = Left | Right A x 
\end{lstlisting}

The apparent syntactic structure of polynomial functors motivates the search for a more synthetic definition that fully and faithfully captures them. One approach to this is the study of \textit{containers} \cite{Abbott2003}\cite{Abbott2005}\cite{Altenkirch2015}(indexed version), which are then associated to endofunctors on \Set{} or \Set{}-slices. Note that these definitions are not \textit{per se} limited to \Set{}, since they are given and validated in a \gls{mltt}; however, due to the difficulty of precisely identifying the class of structures that \gls{mltt} describes\footnote{For an informal discussion, see \cite{Voevodsky2015}.}, it is not immediate to understand how general they are. Analogous issues arise in trying to understand to what flavors of polynomial functors containers correspond.

To further complicate the picture, \textcite{Gambino2009} took a step further and generalised this syntactic approach to syntaxes defined in a general \gls{lccc}, yielding a theory covering indexed polynomial functors in \gls{lccc} slices similarly to how \cite{Altenkirch2015} cover indexed polynomial functors in \Set{}-slices. Again, it is not clear to what extent these theories overlap.

\subsection{Inductive Principles as Initial Algebras}

In both logic and computer science, it is common to encounter definitions given by recursion, as well as proofs given by induction. As illustrated in \cite[Section 10.5]{Awodey2010}, data types with recursive principles can be described categorically as \textit{initial algebras} for an appropriate endofunctor.

The existence of such initial algebra for a given endofunctor is not a trivial problem. For a broad class of endofunctors, under broad assumptions, there is a classical construction due to \textcite{Adamek1974}\footnote{The same construction for \Set{}-endofunctors appeared already in \textcite{Pohlova1973}, as noted in \href{https://ncatlab.org/nlab/show/Ad\%C3\%A1mek\%27s+fixed+point+theorem}{this nLab page}.}; however this construction is ironically non-constructive, in the sense that it employs reasoning schemes that are challenged by constructive mathematicians \cite[Theorem 1.1, discussion]{Pitts2021}. Aside from philosophical quarrels, this poses a problem for computer scientists, as when exhibiting an initial algebra non-constructively, it does not come with computational meaning. In other words, one cannot use it to write programs.

However, inductive definitions are useful in practice, so to different extents they are axiomatized in several type theories. In \gls{mltt}, this is done by the rules presenting so-called \textit{W-types}, i.e. types of well-founded trees\footnote{The fact that the `W' stands for ``well-founded'' is not well documented, but according to \href{https://mathoverflow.net/questions/402435/why-are-w-types-called-w}{this answer} Martin-Löf himself confirmed it.}, axiomatizing initial algebras for all single-sorted polynomial endofunctors (in the sense of \cite{Abbott2005}). This disconnect between the constructive theory of initial algebras and the syntactic axiomatization of W-types further aggravates the difficulty of characterising models of type theories that involve them.

\subsection{Homotopy Type Theory}

\Gls{mltt} was presented in \cite{MartinLoef1998} as a candidate foundation for constructive mathematics, as an alternative to Zermelo–Fraenkel set theory (see \cite[Introduction]{MartinLoef1998}), and its soundness proof was given exhibiting the syntactic model of the theory, in particular a set-theoretical model. \Gls{mltt} was presented as a constructive set theory (see \cite{Nordstroem1990}), despite its inability to internally assess a principle known as \gls{uip}, the lack of which makes for weaker pattern matching\todo[inline]{Cite? Maybe it's in Streicher's thesis}. It became evident that this was not just a technical shortcoming, but rather an unforseen degree of freedom, when \textcite{Hofmann1998} presented the groupoid model of \gls{itt}, ``The first construction of a model in which identity types are non-trivial''\footnote{\url{https://homotopytypetheory.org/references/hofmann-streicher-the-groupoid-interpretation-of-type-theory/}}.

This set forth a research program where models for \gls{itt} were sought in the scope of homotopy theory. This involved interpreting types as homotopy types, taking identity types no longer as being inhabited by equalities between objects but by paths between points, and enriching the type theory with novel constructions called \glspl{hit}, which axiomatize certain non-discrete homotopy types. The novel interpretation of \gls{itt} was called \gls{hott}, its foundations are laid in the ``HoTT Book'' \cite{UnivalentFoundationsProgram2013}.

\section{Project Description}

It is still not clear how \glspl{hit} interact with inductive definitions. One would like to be able to construct or axiomatize initial algebras for endofunctors involving \glspl{hit}. Consider the two similar definitions in Figure \ref{fig:trdefs}:

\bgroup
\renewcommand{\lstlistingname}{Definition}
\begin{figure}
	\caption{Two definitions for unordered binary trees with branching factor \texttt{A}.}
	\label{fig:trdefs}
	\centering
	\begin{minipage}{.45\textwidth}
		\begin{lstlisting}[caption={\gls{hit} based},label={lst:hit}]
data BT1 : Type where
leaf : BT1
branch : (A -> BT1) -> BT1
branch-sym : (ts : A -> BT1)
             (sigma : A -> A)
  -> (isBijection sigma)
  -> branch ts 
      == branch (ts . sigma)
isSet-BT1 :
  (s t : BT1)
  (p q : s == t)
  -> p == q
\end{lstlisting}
	\end{minipage}
	\qquad
	\begin{minipage}{.45\textwidth}
		\begin{lstlisting}[caption={Initial algebra based},label={lst:fix}]
data BTF (X : Type) where
leaf : BTF X
branch : (A -> X) -> BTF X
branch-sym : (ts : A -> X)
             (sigma : A -> A)
  -> (isBijection sigma)
  -> branch ts 
      == branch (ts . sigma)
isset-BTF-X :
  (s t : BTF X)
  (p q : s == t)
  -> p == q

data BT2 : Type where
  fold : BTF BT2 -> BT2
\end{lstlisting}
	\end{minipage}
\end{figure}
\egroup

The definition in Listing \ref{lst:hit} is an example of \gls{hit}: it features not only ground term constructors, but also constructors introducing identities between ground terms, and possibly identities between identities, and so on. Such constructors are called \textit{path constructors} in \gls{hott} parlance.

Semantics for such definitions are not immediately reconduced to previous research on W-types: \textcite{Weide2019} construct Set-truncated \glspl{hit} generated by finitary signatures, assuming the availability of quotients and propositional truncation. Def. \ref{lst:hit} is finitary if and only if \texttt{A} is a finite type. In Section 8, they point out the challenges in performing a similar task in the presence of non finitary constructors.

The second definition is instead given by first defining an endofunctor, \texttt{BTF}, and then defining \texttt{(BT2, fold)} to be the initial algebra for \texttt{BTF}. By the construction in \cite{Weide2019}, again when \texttt{A} is finite, the two definitions are equivalent. Note that in this case, constructions like \cite{Moerdijk2000} and \cite{Pitts2021} fail to apply, since \texttt{BTF} is not polynomial.

Among the efforts to construct or give semantics for \glspl{hit} we must surely note the previously mentioned work by \textcite{Weide2019}, which is limited by finitarity and homotopy level, and \textcite{Fiore2022}, whose construction is given for a broader class of definitions, but involves a non-constructive choice-adjacent principle: this renders the construction inconclusive for computational purposes.

Our intent is to investigate constructability of \glsentrylongpl{hit} with the aim of providing constructions for a broader class of them, or relate their admission in \glsentrylong{hott} to non-constructive principles.

\section{Current work}

\cite{Uustalu2017} gave a syntactic characterisation of monad structures on polynomial endofunctors as generated from containers in \cite{Abbott2005}. We are currently studying how this extends to indexed containers as defined in \cite{Altenkirch2015}, whose monoidal structure has not yet been studied extensively. We suspect that understanding such structures can lead to insight over why, for certain \gls{hit}-defined endofunctors, the admission of initial algebras seems to be associated with non-constructive principles. This is due to the fact that indexed W-types, the inductive principles arising from indexed containers, model multi-sorted term algebras.

\section{Future work}

The scope of \cite{Weide2019} is limited to signatures based on polynomials in the style of \cite{Goldblatt2001}: it begs for a generalization to allow for indexed (finitary) polynomials, as defined in \cite{Altenkirch2015}.

\printacronyms
\printbibliography

\end{document}
